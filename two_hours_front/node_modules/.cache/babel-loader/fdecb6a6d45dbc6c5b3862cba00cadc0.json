{"ast":null,"code":"import _typeof from \"F:/Desktop/two_hours_front/node_modules/@babel/runtime/helpers/esm/typeof.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.json.stringify.js\";\n\n/**\n * 自动布局插件\n * 依赖flowpath插件\n * 未完善\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar POSITION_TYPE = {\n  LEFT_TOP: -1,\n  LEFT: 0,\n  LEFT_BOTTOM: 1\n};\n\nvar AutoLayout =\n/** @class */\nfunction () {\n  function AutoLayout(_a) {\n    var _this = this;\n\n    var lf = _a.lf;\n    this.lf = lf;\n    /**\n     * 用于记录上一次调用layout时计算出的trunk\n     * 当旧trunk和新trunk长度一致时，用于选择旧trunk,\n     * a->b->c->d\n     *    |->e\n     * e后面新增f节点时候，旧逻辑会返回新trunk[a,b,e,f]\n     * 界面布局变成\n     * a->b->e->f\n     *    |->c->d\n     * 其实只想要这样 尽量少变化\n     * a->b->c->d\n     *    |->e->f\n     * */\n\n    this.trunk = []; // 给lf添加方法\n\n    lf.layout = function (startNodeType) {\n      var data = _this.lf.getGraphRawData();\n\n      _this.lf.setStartNodeType(startNodeType);\n\n      var path = _this.lf.getPathes();\n\n      _this.levelHeight = [];\n      _this.newNodeMap = new Map();\n      return _this.layout(data, path);\n    };\n  } // 1) 将所有节点和边的坐标删除。节点上的文本改成偏移量。\n  // 2) 找到长度最长的路径，作为基准路径。\n  // 3) 依次计算\n  // 拿到最长的路径。\n  // nodes: [], edges: [],\n\n\n  AutoLayout.prototype.layout = function (data, path) {\n    var _this = this;\n\n    var trunk = [];\n    path.forEach(function (p) {\n      var elements = p.elements;\n\n      if (elements.length > trunk.length) {\n        trunk = elements;\n      } else if (elements.length === trunk.length) {\n        // 考虑是否替换为旧的trunk\n        if (JSON.stringify(elements) === JSON.stringify(_this.trunk)) {\n          trunk = _this.trunk;\n        }\n      }\n    }); // 记录上一次trunk\n\n    this.trunk = trunk;\n    var nodeMap = this.formatData(data);\n    var newGraphData = {\n      nodes: [],\n      edges: []\n    }; // 从后向前布局\n\n    for (var i = trunk.length - 1; i >= 0; i--) {\n      this.setNodePosition(trunk[i], nodeMap, newGraphData, i, 1);\n    }\n\n    this.lf.graphModel.graphDataToModel(newGraphData);\n  }; // 1) 需要知道下一层级已占高度。\n  // 2) 基于自己的高度，判断下一个层级的高度\n\n\n  AutoLayout.prototype.setNodePosition = function (nodeId, nodeMap, newGraphData, xLevel, yLevel) {\n    var _this = this;\n\n    var n = nodeMap[nodeId];\n    var text = n.text,\n        type = n.type,\n        next = n.next,\n        properties = n.properties;\n    var x = xLevel * 160 + 40;\n    var y = yLevel * 120;\n    var nodeData = {\n      id: nodeId,\n      x: x,\n      text: text,\n      y: y,\n      type: type,\n      properties: properties\n    };\n\n    if (text && _typeof(text) === 'object') {\n      nodeData.text = __assign(__assign({}, text), {\n        x: x + text.x,\n        y: y + text.y\n      });\n    }\n\n    this.newNodeMap.set(nodeData.id, {\n      x: nodeData.x,\n      y: nodeData.y,\n      type: type\n    });\n    newGraphData.nodes.push(nodeData);\n    n.isFixed = true;\n    this.addLevelHeight(xLevel, 1);\n\n    if (next && next.length > 0) {\n      next.forEach(function (nextInfo) {\n        // 如果下一个节点还没有被定位，那么设置其定位\n        var n1 = nodeMap[nextInfo.nodeId];\n\n        if (!n1.isFixed) {\n          var nextYLevel = _this.getLevelHeight(xLevel + 1);\n\n          _this.addLevelHeight(xLevel, 1);\n\n          _this.setNodePosition(nextInfo.nodeId, nodeMap, newGraphData, xLevel + 1, nextYLevel + 1);\n        } else {// todo: 如果下一个节点是已经定位的，则需要考虑边的规避\n        } // 设置连接到下一个节点的边\n        // 1) 起始位置为source节点的下方，结束位置为target节点左边。\n        // 2) 计算折线\n\n\n        newGraphData.edges.push(__assign({\n          id: nextInfo.edgeId,\n          type: nextInfo.edgeType,\n          sourceNodeId: nodeId,\n          targetNodeId: nextInfo.nodeId,\n          properties: nextInfo.properties,\n          text: nextInfo.text\n        }, _this.getEdgeDataPoints(nodeId, nextInfo.nodeId)));\n      });\n    }\n\n    return nodeData;\n  };\n  /**\n   * 1. 处理边上的文本\n   * 2. 主干节点之间直接的边\n   * 3. 一个节点被多个连接作为目标节点，合理分配锚点位置。\n   */\n\n\n  AutoLayout.prototype.getEdgeDataPoints = function (sourceNodeId, targetNodeId) {\n    var source = this.newNodeMap.get(sourceNodeId);\n    var target = this.newNodeMap.get(targetNodeId);\n\n    var _a = this.getShape(sourceNodeId),\n        width = _a.width,\n        height = _a.height;\n\n    var _b = this.getShape(targetNodeId),\n        targetWidth = _b.width,\n        targetHeight = _b.height;\n\n    var postionType = this.getRelativePosition(source, target);\n    var startPoint = {\n      x: source.x,\n      y: source.y\n    };\n    var endPoint = {\n      x: target.x,\n      y: target.y\n    };\n\n    switch (postionType) {\n      case POSITION_TYPE.LEFT:\n        startPoint.x = source.x + width / 2;\n        endPoint.x = target.x - targetWidth / 2;\n        break;\n\n      case POSITION_TYPE.LEFT_TOP:\n        startPoint.y = source.y + height / 2;\n        endPoint.x = target.x - targetWidth / 2;\n        break;\n\n      case POSITION_TYPE.LEFT_BOTTOM:\n        startPoint.x = source.x + width / 2;\n        endPoint.y = target.y + targetHeight / 2;\n        break;\n\n      default:\n        break;\n    }\n\n    return {\n      startPoint: startPoint,\n      endPoint: endPoint\n    };\n  };\n  /**\n   * 获取边的连接节点相对位置。\n   * source一定在target左边。\n   * 1. 如果source和target在同一x, y坐标内容。\n   * 2. 如果source在target左上方。\n   * 3. 如果souce在target左下方。\n   */\n\n\n  AutoLayout.prototype.getRelativePosition = function (source, target) {\n    var y = source.y;\n    var y1 = target.y;\n    var postionType;\n\n    if (y < y1) {\n      postionType = -1;\n    } else if (y === y1) {\n      postionType = 0;\n    } else {\n      postionType = 1;\n    }\n\n    return postionType;\n  };\n  /**\n   * 获取边节点图形的宽高。\n   */\n\n\n  AutoLayout.prototype.getShape = function (nodeId) {\n    var nodeModel = this.lf.getNodeModelById(nodeId);\n    return {\n      height: nodeModel.height,\n      width: nodeModel.width\n    };\n  };\n\n  AutoLayout.prototype.formatData = function (data) {\n    var nodeMap = data.nodes.reduce(function (nMap, node) {\n      var type = node.type,\n          properties = node.properties,\n          text = node.text,\n          x = node.x,\n          y = node.y;\n\n      if (text && _typeof(text) === 'object') {\n        // 坐标转换为偏移量\n        text.x = text.x - x;\n        text.y = text.y - y;\n      }\n\n      nMap[node.id] = {\n        type: type,\n        properties: properties,\n        text: text,\n        prev: [],\n        next: []\n      };\n      return nMap;\n    }, {});\n    data.edges.forEach(function (edge) {\n      var sourceNodeId = edge.sourceNodeId,\n          targetNodeId = edge.targetNodeId,\n          id = edge.id,\n          properties = edge.properties,\n          text = edge.text;\n      var newText = text;\n\n      if (_typeof(text) === 'object') {\n        newText = text.value;\n      }\n\n      nodeMap[sourceNodeId].next.push({\n        edgeId: id,\n        nodeId: targetNodeId,\n        edgeType: edge.type,\n        properties: properties,\n        text: newText\n      });\n      nodeMap[targetNodeId].prev.push({\n        edgeId: id,\n        nodeId: sourceNodeId,\n        properties: properties,\n        text: newText\n      });\n    });\n    return nodeMap;\n  };\n\n  AutoLayout.prototype.addLevelHeight = function (level, height, isNegative) {\n    if (height === void 0) {\n      height = 1;\n    }\n\n    if (isNegative === void 0) {\n      isNegative = false;\n    }\n\n    var l = this.levelHeight[level];\n\n    if (!l) {\n      l = {\n        positiveHeight: 0,\n        negativeHeight: 0\n      };\n      this.levelHeight[level] = l;\n    }\n\n    isNegative ? l.negativeHeight -= height : l.positiveHeight += height;\n  };\n\n  AutoLayout.prototype.getLevelHeight = function (level, isNegative) {\n    if (isNegative === void 0) {\n      isNegative = false;\n    }\n\n    var val = this.levelHeight[level];\n\n    if (!val) {\n      return 0;\n    }\n\n    return isNegative ? val.negativeHeight : val.positiveHeight;\n  };\n\n  AutoLayout.pluginName = 'AutoLayout';\n  return AutoLayout;\n}();\n\nexport { AutoLayout };","map":{"version":3,"sources":["F:/Desktop/two_hours_front/node_modules/@logicflow/extension/es/tools/auto-layout/index.js"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","POSITION_TYPE","LEFT_TOP","LEFT","LEFT_BOTTOM","AutoLayout","_a","_this","lf","trunk","layout","startNodeType","data","getGraphRawData","setStartNodeType","path","getPathes","levelHeight","newNodeMap","Map","forEach","elements","JSON","stringify","nodeMap","formatData","newGraphData","nodes","edges","setNodePosition","graphModel","graphDataToModel","nodeId","xLevel","yLevel","text","type","next","properties","x","y","nodeData","id","set","push","isFixed","addLevelHeight","nextInfo","n1","nextYLevel","getLevelHeight","edgeId","edgeType","sourceNodeId","targetNodeId","getEdgeDataPoints","source","get","target","getShape","width","height","_b","targetWidth","targetHeight","postionType","getRelativePosition","startPoint","endPoint","y1","nodeModel","getNodeModelById","reduce","nMap","node","prev","edge","newText","value","level","isNegative","l","positiveHeight","negativeHeight","val","pluginName"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,QAAQ,GAAI,QAAQ,KAAKA,QAAd,IAA2B,YAAY;AAClDA,EAAAA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAASC,CAAT,EAAY;AACpC,SAAK,IAAIC,CAAJ,EAAOC,CAAC,GAAG,CAAX,EAAcC,CAAC,GAAGC,SAAS,CAACC,MAAjC,EAAyCH,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAqD;AACjDD,MAAAA,CAAC,GAAGG,SAAS,CAACF,CAAD,CAAb;;AACA,WAAK,IAAII,CAAT,IAAcL,CAAd;AAAiB,YAAIH,MAAM,CAACS,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EACbN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AADJ;AAEH;;AACD,WAAON,CAAP;AACH,GAPD;;AAQA,SAAOH,QAAQ,CAACa,KAAT,CAAe,IAAf,EAAqBN,SAArB,CAAP;AACH,CAVD;;AAWA,IAAIO,aAAa,GAAG;AAChBC,EAAAA,QAAQ,EAAE,CAAC,CADK;AAEhBC,EAAAA,IAAI,EAAE,CAFU;AAGhBC,EAAAA,WAAW,EAAE;AAHG,CAApB;;AAKA,IAAIC,UAAU;AAAG;AAAe,YAAY;AACxC,WAASA,UAAT,CAAoBC,EAApB,EAAwB;AACpB,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAIC,EAAE,GAAGF,EAAE,CAACE,EAAZ;AACA,SAAKA,EAAL,GAAUA,EAAV;AACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,SAAKC,KAAL,GAAa,EAAb,CAjBoB,CAkBpB;;AACAD,IAAAA,EAAE,CAACE,MAAH,GAAY,UAAUC,aAAV,EAAyB;AACjC,UAAIC,IAAI,GAAGL,KAAK,CAACC,EAAN,CAASK,eAAT,EAAX;;AACAN,MAAAA,KAAK,CAACC,EAAN,CAASM,gBAAT,CAA0BH,aAA1B;;AACA,UAAII,IAAI,GAAGR,KAAK,CAACC,EAAN,CAASQ,SAAT,EAAX;;AACAT,MAAAA,KAAK,CAACU,WAAN,GAAoB,EAApB;AACAV,MAAAA,KAAK,CAACW,UAAN,GAAmB,IAAIC,GAAJ,EAAnB;AACA,aAAOZ,KAAK,CAACG,MAAN,CAAaE,IAAb,EAAmBG,IAAnB,CAAP;AACH,KAPD;AAQH,GA5BuC,CA6BxC;AACA;AACA;AACA;AACA;;;AACAV,EAAAA,UAAU,CAACR,SAAX,CAAqBa,MAArB,GAA8B,UAAUE,IAAV,EAAgBG,IAAhB,EAAsB;AAChD,QAAIR,KAAK,GAAG,IAAZ;;AACA,QAAIE,KAAK,GAAG,EAAZ;AACAM,IAAAA,IAAI,CAACK,OAAL,CAAa,UAAUxB,CAAV,EAAa;AACtB,UAAIyB,QAAQ,GAAGzB,CAAC,CAACyB,QAAjB;;AACA,UAAIA,QAAQ,CAAC1B,MAAT,GAAkBc,KAAK,CAACd,MAA5B,EAAoC;AAChCc,QAAAA,KAAK,GAAGY,QAAR;AACH,OAFD,MAGK,IAAIA,QAAQ,CAAC1B,MAAT,KAAoBc,KAAK,CAACd,MAA9B,EAAsC;AACvC;AACA,YAAI2B,IAAI,CAACC,SAAL,CAAeF,QAAf,MAA6BC,IAAI,CAACC,SAAL,CAAehB,KAAK,CAACE,KAArB,CAAjC,EAA8D;AAC1DA,UAAAA,KAAK,GAAGF,KAAK,CAACE,KAAd;AACH;AACJ;AACJ,KAXD,EAHgD,CAehD;;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA,QAAIe,OAAO,GAAG,KAAKC,UAAL,CAAgBb,IAAhB,CAAd;AACA,QAAIc,YAAY,GAAG;AACfC,MAAAA,KAAK,EAAE,EADQ;AAEfC,MAAAA,KAAK,EAAE;AAFQ,KAAnB,CAlBgD,CAsBhD;;AACA,SAAK,IAAIpC,CAAC,GAAGiB,KAAK,CAACd,MAAN,GAAe,CAA5B,EAA+BH,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;AACxC,WAAKqC,eAAL,CAAqBpB,KAAK,CAACjB,CAAD,CAA1B,EAA+BgC,OAA/B,EAAwCE,YAAxC,EAAsDlC,CAAtD,EAAyD,CAAzD;AACH;;AACD,SAAKgB,EAAL,CAAQsB,UAAR,CAAmBC,gBAAnB,CAAoCL,YAApC;AACH,GA3BD,CAlCwC,CA8DxC;AACA;;;AACArB,EAAAA,UAAU,CAACR,SAAX,CAAqBgC,eAArB,GAAuC,UAAUG,MAAV,EAAkBR,OAAlB,EAA2BE,YAA3B,EAAyCO,MAAzC,EAAiDC,MAAjD,EAAyD;AAC5F,QAAI3B,KAAK,GAAG,IAAZ;;AACA,QAAId,CAAC,GAAG+B,OAAO,CAACQ,MAAD,CAAf;AACA,QAAIG,IAAI,GAAG1C,CAAC,CAAC0C,IAAb;AAAA,QAAmBC,IAAI,GAAG3C,CAAC,CAAC2C,IAA5B;AAAA,QAAkCC,IAAI,GAAG5C,CAAC,CAAC4C,IAA3C;AAAA,QAAiDC,UAAU,GAAG7C,CAAC,CAAC6C,UAAhE;AACA,QAAIC,CAAC,GAAGN,MAAM,GAAG,GAAT,GAAe,EAAvB;AACA,QAAIO,CAAC,GAAGN,MAAM,GAAG,GAAjB;AACA,QAAIO,QAAQ,GAAG;AACXC,MAAAA,EAAE,EAAEV,MADO;AAEXO,MAAAA,CAAC,EAAEA,CAFQ;AAGXJ,MAAAA,IAAI,EAAEA,IAHK;AAIXK,MAAAA,CAAC,EAAEA,CAJQ;AAKXJ,MAAAA,IAAI,EAAEA,IALK;AAMXE,MAAAA,UAAU,EAAEA;AAND,KAAf;;AAQA,QAAIH,IAAI,IAAI,QAAOA,IAAP,MAAgB,QAA5B,EAAsC;AAClCM,MAAAA,QAAQ,CAACN,IAAT,GAAgBhD,QAAQ,CAACA,QAAQ,CAAC,EAAD,EAAKgD,IAAL,CAAT,EAAqB;AAAEI,QAAAA,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAACI,CAAd;AAAiBC,QAAAA,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAACK;AAA7B,OAArB,CAAxB;AACH;;AACD,SAAKtB,UAAL,CAAgByB,GAAhB,CAAoBF,QAAQ,CAACC,EAA7B,EAAiC;AAC7BH,MAAAA,CAAC,EAAEE,QAAQ,CAACF,CADiB;AAE7BC,MAAAA,CAAC,EAAEC,QAAQ,CAACD,CAFiB;AAG7BJ,MAAAA,IAAI,EAAEA;AAHuB,KAAjC;AAKAV,IAAAA,YAAY,CAACC,KAAb,CAAmBiB,IAAnB,CAAwBH,QAAxB;AACAhD,IAAAA,CAAC,CAACoD,OAAF,GAAY,IAAZ;AACA,SAAKC,cAAL,CAAoBb,MAApB,EAA4B,CAA5B;;AACA,QAAII,IAAI,IAAIA,IAAI,CAAC1C,MAAL,GAAc,CAA1B,EAA6B;AACzB0C,MAAAA,IAAI,CAACjB,OAAL,CAAa,UAAU2B,QAAV,EAAoB;AAC7B;AACA,YAAIC,EAAE,GAAGxB,OAAO,CAACuB,QAAQ,CAACf,MAAV,CAAhB;;AACA,YAAI,CAACgB,EAAE,CAACH,OAAR,EAAiB;AACb,cAAII,UAAU,GAAG1C,KAAK,CAAC2C,cAAN,CAAqBjB,MAAM,GAAG,CAA9B,CAAjB;;AACA1B,UAAAA,KAAK,CAACuC,cAAN,CAAqBb,MAArB,EAA6B,CAA7B;;AACA1B,UAAAA,KAAK,CAACsB,eAAN,CAAsBkB,QAAQ,CAACf,MAA/B,EAAuCR,OAAvC,EAAgDE,YAAhD,EAA8DO,MAAM,GAAG,CAAvE,EAA0EgB,UAAU,GAAG,CAAvF;AACH,SAJD,MAKK,CACD;AACH,SAV4B,CAW7B;AACA;AACA;;;AACAvB,QAAAA,YAAY,CAACE,KAAb,CAAmBgB,IAAnB,CAAwBzD,QAAQ,CAAC;AAAEuD,UAAAA,EAAE,EAAEK,QAAQ,CAACI,MAAf;AAAuBf,UAAAA,IAAI,EAAEW,QAAQ,CAACK,QAAtC;AAAgDC,UAAAA,YAAY,EAAErB,MAA9D;AAAsEsB,UAAAA,YAAY,EAAEP,QAAQ,CAACf,MAA7F;AAAqGM,UAAAA,UAAU,EAAES,QAAQ,CAACT,UAA1H;AAAsIH,UAAAA,IAAI,EAAEY,QAAQ,CAACZ;AAArJ,SAAD,EAA8J5B,KAAK,CAACgD,iBAAN,CAAwBvB,MAAxB,EAAgCe,QAAQ,CAACf,MAAzC,CAA9J,CAAhC;AACH,OAfD;AAgBH;;AACD,WAAOS,QAAP;AACH,GA5CD;AA6CA;AACJ;AACA;AACA;AACA;;;AACIpC,EAAAA,UAAU,CAACR,SAAX,CAAqB0D,iBAArB,GAAyC,UAAUF,YAAV,EAAwBC,YAAxB,EAAsC;AAC3E,QAAIE,MAAM,GAAG,KAAKtC,UAAL,CAAgBuC,GAAhB,CAAoBJ,YAApB,CAAb;AACA,QAAIK,MAAM,GAAG,KAAKxC,UAAL,CAAgBuC,GAAhB,CAAoBH,YAApB,CAAb;;AACA,QAAIhD,EAAE,GAAG,KAAKqD,QAAL,CAAcN,YAAd,CAAT;AAAA,QAAsCO,KAAK,GAAGtD,EAAE,CAACsD,KAAjD;AAAA,QAAwDC,MAAM,GAAGvD,EAAE,CAACuD,MAApE;;AACA,QAAIC,EAAE,GAAG,KAAKH,QAAL,CAAcL,YAAd,CAAT;AAAA,QAAsCS,WAAW,GAAGD,EAAE,CAACF,KAAvD;AAAA,QAA8DI,YAAY,GAAGF,EAAE,CAACD,MAAhF;;AACA,QAAII,WAAW,GAAG,KAAKC,mBAAL,CAAyBV,MAAzB,EAAiCE,MAAjC,CAAlB;AACA,QAAIS,UAAU,GAAG;AACb5B,MAAAA,CAAC,EAAEiB,MAAM,CAACjB,CADG;AAEbC,MAAAA,CAAC,EAAEgB,MAAM,CAAChB;AAFG,KAAjB;AAIA,QAAI4B,QAAQ,GAAG;AACX7B,MAAAA,CAAC,EAAEmB,MAAM,CAACnB,CADC;AAEXC,MAAAA,CAAC,EAAEkB,MAAM,CAAClB;AAFC,KAAf;;AAIA,YAAQyB,WAAR;AACI,WAAKhE,aAAa,CAACE,IAAnB;AACIgE,QAAAA,UAAU,CAAC5B,CAAX,GAAeiB,MAAM,CAACjB,CAAP,GAAWqB,KAAK,GAAG,CAAlC;AACAQ,QAAAA,QAAQ,CAAC7B,CAAT,GAAamB,MAAM,CAACnB,CAAP,GAAWwB,WAAW,GAAG,CAAtC;AACA;;AACJ,WAAK9D,aAAa,CAACC,QAAnB;AACIiE,QAAAA,UAAU,CAAC3B,CAAX,GAAegB,MAAM,CAAChB,CAAP,GAAWqB,MAAM,GAAG,CAAnC;AACAO,QAAAA,QAAQ,CAAC7B,CAAT,GAAamB,MAAM,CAACnB,CAAP,GAAWwB,WAAW,GAAG,CAAtC;AACA;;AACJ,WAAK9D,aAAa,CAACG,WAAnB;AACI+D,QAAAA,UAAU,CAAC5B,CAAX,GAAeiB,MAAM,CAACjB,CAAP,GAAWqB,KAAK,GAAG,CAAlC;AACAQ,QAAAA,QAAQ,CAAC5B,CAAT,GAAakB,MAAM,CAAClB,CAAP,GAAWwB,YAAY,GAAG,CAAvC;AACA;;AACJ;AACI;AAdR;;AAgBA,WAAO;AACHG,MAAAA,UAAU,EAAEA,UADT;AAEHC,MAAAA,QAAQ,EAAEA;AAFP,KAAP;AAIH,GAlCD;AAmCA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI/D,EAAAA,UAAU,CAACR,SAAX,CAAqBqE,mBAArB,GAA2C,UAAUV,MAAV,EAAkBE,MAAlB,EAA0B;AACjE,QAAIlB,CAAC,GAAGgB,MAAM,CAAChB,CAAf;AACA,QAAI6B,EAAE,GAAGX,MAAM,CAAClB,CAAhB;AACA,QAAIyB,WAAJ;;AACA,QAAIzB,CAAC,GAAG6B,EAAR,EAAY;AACRJ,MAAAA,WAAW,GAAG,CAAC,CAAf;AACH,KAFD,MAGK,IAAIzB,CAAC,KAAK6B,EAAV,EAAc;AACfJ,MAAAA,WAAW,GAAG,CAAd;AACH,KAFI,MAGA;AACDA,MAAAA,WAAW,GAAG,CAAd;AACH;;AACD,WAAOA,WAAP;AACH,GAdD;AAeA;AACJ;AACA;;;AACI5D,EAAAA,UAAU,CAACR,SAAX,CAAqB8D,QAArB,GAAgC,UAAU3B,MAAV,EAAkB;AAC9C,QAAIsC,SAAS,GAAG,KAAK9D,EAAL,CAAQ+D,gBAAR,CAAyBvC,MAAzB,CAAhB;AACA,WAAO;AACH6B,MAAAA,MAAM,EAAES,SAAS,CAACT,MADf;AAEHD,MAAAA,KAAK,EAAEU,SAAS,CAACV;AAFd,KAAP;AAIH,GAND;;AAOAvD,EAAAA,UAAU,CAACR,SAAX,CAAqB4B,UAArB,GAAkC,UAAUb,IAAV,EAAgB;AAC9C,QAAIY,OAAO,GAAGZ,IAAI,CAACe,KAAL,CAAW6C,MAAX,CAAkB,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AAClD,UAAItC,IAAI,GAAGsC,IAAI,CAACtC,IAAhB;AAAA,UAAsBE,UAAU,GAAGoC,IAAI,CAACpC,UAAxC;AAAA,UAAoDH,IAAI,GAAGuC,IAAI,CAACvC,IAAhE;AAAA,UAAsEI,CAAC,GAAGmC,IAAI,CAACnC,CAA/E;AAAA,UAAkFC,CAAC,GAAGkC,IAAI,CAAClC,CAA3F;;AACA,UAAIL,IAAI,IAAI,QAAOA,IAAP,MAAgB,QAA5B,EAAsC;AAClC;AACAA,QAAAA,IAAI,CAACI,CAAL,GAASJ,IAAI,CAACI,CAAL,GAASA,CAAlB;AACAJ,QAAAA,IAAI,CAACK,CAAL,GAASL,IAAI,CAACK,CAAL,GAASA,CAAlB;AACH;;AACDiC,MAAAA,IAAI,CAACC,IAAI,CAAChC,EAAN,CAAJ,GAAgB;AACZN,QAAAA,IAAI,EAAEA,IADM;AAEZE,QAAAA,UAAU,EAAEA,UAFA;AAGZH,QAAAA,IAAI,EAAEA,IAHM;AAIZwC,QAAAA,IAAI,EAAE,EAJM;AAKZtC,QAAAA,IAAI,EAAE;AALM,OAAhB;AAOA,aAAOoC,IAAP;AACH,KAfa,EAeX,EAfW,CAAd;AAgBA7D,IAAAA,IAAI,CAACgB,KAAL,CAAWR,OAAX,CAAmB,UAAUwD,IAAV,EAAgB;AAC/B,UAAIvB,YAAY,GAAGuB,IAAI,CAACvB,YAAxB;AAAA,UAAsCC,YAAY,GAAGsB,IAAI,CAACtB,YAA1D;AAAA,UAAwEZ,EAAE,GAAGkC,IAAI,CAAClC,EAAlF;AAAA,UAAsFJ,UAAU,GAAGsC,IAAI,CAACtC,UAAxG;AAAA,UAAoHH,IAAI,GAAGyC,IAAI,CAACzC,IAAhI;AACA,UAAI0C,OAAO,GAAG1C,IAAd;;AACA,UAAI,QAAOA,IAAP,MAAgB,QAApB,EAA8B;AAC1B0C,QAAAA,OAAO,GAAG1C,IAAI,CAAC2C,KAAf;AACH;;AACDtD,MAAAA,OAAO,CAAC6B,YAAD,CAAP,CAAsBhB,IAAtB,CAA2BO,IAA3B,CAAgC;AAC5BO,QAAAA,MAAM,EAAET,EADoB;AAE5BV,QAAAA,MAAM,EAAEsB,YAFoB;AAG5BF,QAAAA,QAAQ,EAAEwB,IAAI,CAACxC,IAHa;AAI5BE,QAAAA,UAAU,EAAEA,UAJgB;AAK5BH,QAAAA,IAAI,EAAE0C;AALsB,OAAhC;AAOArD,MAAAA,OAAO,CAAC8B,YAAD,CAAP,CAAsBqB,IAAtB,CAA2B/B,IAA3B,CAAgC;AAC5BO,QAAAA,MAAM,EAAET,EADoB;AAE5BV,QAAAA,MAAM,EAAEqB,YAFoB;AAG5Bf,QAAAA,UAAU,EAAEA,UAHgB;AAI5BH,QAAAA,IAAI,EAAE0C;AAJsB,OAAhC;AAMH,KAnBD;AAoBA,WAAOrD,OAAP;AACH,GAtCD;;AAuCAnB,EAAAA,UAAU,CAACR,SAAX,CAAqBiD,cAArB,GAAsC,UAAUiC,KAAV,EAAiBlB,MAAjB,EAAyBmB,UAAzB,EAAqC;AACvE,QAAInB,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,MAAAA,MAAM,GAAG,CAAT;AAAa;;AACtC,QAAImB,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG,KAAb;AAAqB;;AAClD,QAAIC,CAAC,GAAG,KAAKhE,WAAL,CAAiB8D,KAAjB,CAAR;;AACA,QAAI,CAACE,CAAL,EAAQ;AACJA,MAAAA,CAAC,GAAG;AACAC,QAAAA,cAAc,EAAE,CADhB;AAEAC,QAAAA,cAAc,EAAE;AAFhB,OAAJ;AAIA,WAAKlE,WAAL,CAAiB8D,KAAjB,IAA0BE,CAA1B;AACH;;AACDD,IAAAA,UAAU,GAAIC,CAAC,CAACE,cAAF,IAAoBtB,MAAxB,GAAmCoB,CAAC,CAACC,cAAF,IAAoBrB,MAAjE;AACH,GAZD;;AAaAxD,EAAAA,UAAU,CAACR,SAAX,CAAqBqD,cAArB,GAAsC,UAAU6B,KAAV,EAAiBC,UAAjB,EAA6B;AAC/D,QAAIA,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG,KAAb;AAAqB;;AAClD,QAAII,GAAG,GAAG,KAAKnE,WAAL,CAAiB8D,KAAjB,CAAV;;AACA,QAAI,CAACK,GAAL,EAAU;AACN,aAAO,CAAP;AACH;;AACD,WAAOJ,UAAU,GAAGI,GAAG,CAACD,cAAP,GAAwBC,GAAG,CAACF,cAA7C;AACH,GAPD;;AAQA7E,EAAAA,UAAU,CAACgF,UAAX,GAAwB,YAAxB;AACA,SAAOhF,UAAP;AACH,CAnP+B,EAAhC;;AAoPA,SAASA,UAAT","sourcesContent":["/**\n * 自动布局插件\n * 依赖flowpath插件\n * 未完善\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar POSITION_TYPE = {\n    LEFT_TOP: -1,\n    LEFT: 0,\n    LEFT_BOTTOM: 1,\n};\nvar AutoLayout = /** @class */ (function () {\n    function AutoLayout(_a) {\n        var _this = this;\n        var lf = _a.lf;\n        this.lf = lf;\n        /**\n         * 用于记录上一次调用layout时计算出的trunk\n         * 当旧trunk和新trunk长度一致时，用于选择旧trunk,\n         * a->b->c->d\n         *    |->e\n         * e后面新增f节点时候，旧逻辑会返回新trunk[a,b,e,f]\n         * 界面布局变成\n         * a->b->e->f\n         *    |->c->d\n         * 其实只想要这样 尽量少变化\n         * a->b->c->d\n         *    |->e->f\n         * */\n        this.trunk = [];\n        // 给lf添加方法\n        lf.layout = function (startNodeType) {\n            var data = _this.lf.getGraphRawData();\n            _this.lf.setStartNodeType(startNodeType);\n            var path = _this.lf.getPathes();\n            _this.levelHeight = [];\n            _this.newNodeMap = new Map();\n            return _this.layout(data, path);\n        };\n    }\n    // 1) 将所有节点和边的坐标删除。节点上的文本改成偏移量。\n    // 2) 找到长度最长的路径，作为基准路径。\n    // 3) 依次计算\n    // 拿到最长的路径。\n    // nodes: [], edges: [],\n    AutoLayout.prototype.layout = function (data, path) {\n        var _this = this;\n        var trunk = [];\n        path.forEach(function (p) {\n            var elements = p.elements;\n            if (elements.length > trunk.length) {\n                trunk = elements;\n            }\n            else if (elements.length === trunk.length) {\n                // 考虑是否替换为旧的trunk\n                if (JSON.stringify(elements) === JSON.stringify(_this.trunk)) {\n                    trunk = _this.trunk;\n                }\n            }\n        });\n        // 记录上一次trunk\n        this.trunk = trunk;\n        var nodeMap = this.formatData(data);\n        var newGraphData = {\n            nodes: [],\n            edges: [],\n        };\n        // 从后向前布局\n        for (var i = trunk.length - 1; i >= 0; i--) {\n            this.setNodePosition(trunk[i], nodeMap, newGraphData, i, 1);\n        }\n        this.lf.graphModel.graphDataToModel(newGraphData);\n    };\n    // 1) 需要知道下一层级已占高度。\n    // 2) 基于自己的高度，判断下一个层级的高度\n    AutoLayout.prototype.setNodePosition = function (nodeId, nodeMap, newGraphData, xLevel, yLevel) {\n        var _this = this;\n        var n = nodeMap[nodeId];\n        var text = n.text, type = n.type, next = n.next, properties = n.properties;\n        var x = xLevel * 160 + 40;\n        var y = yLevel * 120;\n        var nodeData = {\n            id: nodeId,\n            x: x,\n            text: text,\n            y: y,\n            type: type,\n            properties: properties,\n        };\n        if (text && typeof text === 'object') {\n            nodeData.text = __assign(__assign({}, text), { x: x + text.x, y: y + text.y });\n        }\n        this.newNodeMap.set(nodeData.id, {\n            x: nodeData.x,\n            y: nodeData.y,\n            type: type,\n        });\n        newGraphData.nodes.push(nodeData);\n        n.isFixed = true;\n        this.addLevelHeight(xLevel, 1);\n        if (next && next.length > 0) {\n            next.forEach(function (nextInfo) {\n                // 如果下一个节点还没有被定位，那么设置其定位\n                var n1 = nodeMap[nextInfo.nodeId];\n                if (!n1.isFixed) {\n                    var nextYLevel = _this.getLevelHeight(xLevel + 1);\n                    _this.addLevelHeight(xLevel, 1);\n                    _this.setNodePosition(nextInfo.nodeId, nodeMap, newGraphData, xLevel + 1, nextYLevel + 1);\n                }\n                else {\n                    // todo: 如果下一个节点是已经定位的，则需要考虑边的规避\n                }\n                // 设置连接到下一个节点的边\n                // 1) 起始位置为source节点的下方，结束位置为target节点左边。\n                // 2) 计算折线\n                newGraphData.edges.push(__assign({ id: nextInfo.edgeId, type: nextInfo.edgeType, sourceNodeId: nodeId, targetNodeId: nextInfo.nodeId, properties: nextInfo.properties, text: nextInfo.text }, _this.getEdgeDataPoints(nodeId, nextInfo.nodeId)));\n            });\n        }\n        return nodeData;\n    };\n    /**\n     * 1. 处理边上的文本\n     * 2. 主干节点之间直接的边\n     * 3. 一个节点被多个连接作为目标节点，合理分配锚点位置。\n     */\n    AutoLayout.prototype.getEdgeDataPoints = function (sourceNodeId, targetNodeId) {\n        var source = this.newNodeMap.get(sourceNodeId);\n        var target = this.newNodeMap.get(targetNodeId);\n        var _a = this.getShape(sourceNodeId), width = _a.width, height = _a.height;\n        var _b = this.getShape(targetNodeId), targetWidth = _b.width, targetHeight = _b.height;\n        var postionType = this.getRelativePosition(source, target);\n        var startPoint = {\n            x: source.x,\n            y: source.y,\n        };\n        var endPoint = {\n            x: target.x,\n            y: target.y,\n        };\n        switch (postionType) {\n            case POSITION_TYPE.LEFT:\n                startPoint.x = source.x + width / 2;\n                endPoint.x = target.x - targetWidth / 2;\n                break;\n            case POSITION_TYPE.LEFT_TOP:\n                startPoint.y = source.y + height / 2;\n                endPoint.x = target.x - targetWidth / 2;\n                break;\n            case POSITION_TYPE.LEFT_BOTTOM:\n                startPoint.x = source.x + width / 2;\n                endPoint.y = target.y + targetHeight / 2;\n                break;\n            default:\n                break;\n        }\n        return {\n            startPoint: startPoint,\n            endPoint: endPoint,\n        };\n    };\n    /**\n     * 获取边的连接节点相对位置。\n     * source一定在target左边。\n     * 1. 如果source和target在同一x, y坐标内容。\n     * 2. 如果source在target左上方。\n     * 3. 如果souce在target左下方。\n     */\n    AutoLayout.prototype.getRelativePosition = function (source, target) {\n        var y = source.y;\n        var y1 = target.y;\n        var postionType;\n        if (y < y1) {\n            postionType = -1;\n        }\n        else if (y === y1) {\n            postionType = 0;\n        }\n        else {\n            postionType = 1;\n        }\n        return postionType;\n    };\n    /**\n     * 获取边节点图形的宽高。\n     */\n    AutoLayout.prototype.getShape = function (nodeId) {\n        var nodeModel = this.lf.getNodeModelById(nodeId);\n        return {\n            height: nodeModel.height,\n            width: nodeModel.width,\n        };\n    };\n    AutoLayout.prototype.formatData = function (data) {\n        var nodeMap = data.nodes.reduce(function (nMap, node) {\n            var type = node.type, properties = node.properties, text = node.text, x = node.x, y = node.y;\n            if (text && typeof text === 'object') {\n                // 坐标转换为偏移量\n                text.x = text.x - x;\n                text.y = text.y - y;\n            }\n            nMap[node.id] = {\n                type: type,\n                properties: properties,\n                text: text,\n                prev: [],\n                next: [],\n            };\n            return nMap;\n        }, {});\n        data.edges.forEach(function (edge) {\n            var sourceNodeId = edge.sourceNodeId, targetNodeId = edge.targetNodeId, id = edge.id, properties = edge.properties, text = edge.text;\n            var newText = text;\n            if (typeof text === 'object') {\n                newText = text.value;\n            }\n            nodeMap[sourceNodeId].next.push({\n                edgeId: id,\n                nodeId: targetNodeId,\n                edgeType: edge.type,\n                properties: properties,\n                text: newText,\n            });\n            nodeMap[targetNodeId].prev.push({\n                edgeId: id,\n                nodeId: sourceNodeId,\n                properties: properties,\n                text: newText,\n            });\n        });\n        return nodeMap;\n    };\n    AutoLayout.prototype.addLevelHeight = function (level, height, isNegative) {\n        if (height === void 0) { height = 1; }\n        if (isNegative === void 0) { isNegative = false; }\n        var l = this.levelHeight[level];\n        if (!l) {\n            l = {\n                positiveHeight: 0,\n                negativeHeight: 0,\n            };\n            this.levelHeight[level] = l;\n        }\n        isNegative ? (l.negativeHeight -= height) : (l.positiveHeight += height);\n    };\n    AutoLayout.prototype.getLevelHeight = function (level, isNegative) {\n        if (isNegative === void 0) { isNegative = false; }\n        var val = this.levelHeight[level];\n        if (!val) {\n            return 0;\n        }\n        return isNegative ? val.negativeHeight : val.positiveHeight;\n    };\n    AutoLayout.pluginName = 'AutoLayout';\n    return AutoLayout;\n}());\nexport { AutoLayout };\n"]},"metadata":{},"sourceType":"module"}