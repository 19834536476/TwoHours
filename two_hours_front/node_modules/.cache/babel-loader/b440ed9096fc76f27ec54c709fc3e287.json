{"ast":null,"code":"import \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.map.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.array.sort.js\";\n\n/**\n * 路径插件，此插件支持获取绘制的图中所有的路径。\n * 需要指定开始节点类型。\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n};\n\nimport { getBpmnId } from '../../bpmn/getBpmnId';\n\nvar FlowPath =\n/** @class */\nfunction () {\n  function FlowPath(_a) {\n    var _this = this;\n\n    var lf = _a.lf;\n    this.lf = lf;\n    this.pathes = []; // 给lf添加方法\n\n    lf.getPathes = function () {\n      if (!_this.startNodeType) {\n        throw new Error('需要预先指定开始节点类型');\n      }\n\n      return _this.getPathes();\n    };\n\n    lf.setRawPathes = function (pathes) {\n      _this.setPathes(pathes);\n    };\n\n    lf.getRawPathes = function () {\n      return _this.pathes;\n    };\n\n    lf.setStartNodeType = function (type) {\n      _this.startNodeType = type;\n    };\n  }\n\n  FlowPath.prototype.setPathes = function (pathes) {\n    this.pathes = pathes.map(function (_a) {\n      var routeId = _a.routeId,\n          name = _a.name,\n          elements = _a.elements,\n          type = _a.type;\n      return {\n        routeId: routeId,\n        name: name,\n        elements: elements,\n        type: type,\n        similarElement: null,\n        weight: 0\n      };\n    });\n  };\n\n  FlowPath.prototype.getPathes = function () {\n    var _this = this;\n\n    var graphData = this.lf.getGraphRawData();\n    var nodesMap = new Map();\n    var startNodeIds = [];\n    graphData.nodes.forEach(function (node) {\n      nodesMap.set(node.id, {\n        id: node.id,\n        data: node,\n        nextNodes: []\n      });\n\n      if (node.type === _this.startNodeType) {\n        startNodeIds.push(node.id);\n      }\n    });\n    graphData.edges.forEach(function (edge) {\n      var node = nodesMap.get(edge.sourceNodeId);\n      node.nextNodes.push(edge.targetNodeId);\n    });\n    var pathElements = [];\n    startNodeIds.forEach(function (id) {\n      pathElements = pathElements.concat(_this.findPathElements(nodesMap.get(id), nodesMap, []));\n    });\n    return this.getNewPathes(pathElements);\n  };\n\n  FlowPath.prototype.findPathElements = function (node, nodesMap, elements) {\n    if (elements === void 0) {\n      elements = [];\n    }\n\n    var newPathes = __spread(elements);\n\n    newPathes.push(node.id);\n\n    if (node.nextNodes.length === 0) {\n      return [newPathes];\n    }\n\n    var subPath = [];\n\n    for (var i = 0; i < node.nextNodes.length; i++) {\n      var n = nodesMap.get(node.nextNodes[i]);\n      var p = void 0; // 循环路径\n\n      var idx = newPathes.indexOf(n.id);\n\n      if (idx !== -1) {\n        p = [__spread(newPathes.slice(idx), [n.id])];\n      } else {\n        p = this.findPathElements(n, nodesMap, __spread(newPathes));\n      }\n\n      subPath = subPath.concat(p);\n    }\n\n    return subPath;\n  };\n  /**\n   * 设置路径id\n   * 如果存在原始路径Id, 则需要比较新路径是否在原始路径中存在相似路径\n   * 如果有，则尽量使用原始路径。\n   * 相似路径\n   * 1. 如果所有的节点都相同，则必定为同一路径。(包括顺序不同)\n   * 2. 如果新路径比原来路径少了或者多了部分节点，则记录为相似路径。基于不同的差异，标记不同的权重。\n   * 3. 基于新路径在旧路径占用权限，设置新路径Id.\n   * 4. 如果某一条旧路径被多条新路径标记为相同的权重，则这两条新路径都使用新Id.\n   */\n\n\n  FlowPath.prototype.getNewPathes = function (pathElements) {\n    var _this = this;\n\n    var pathes = []; // 由于循环路径不包括开始，所以存在重复的情况，此处去重。\n\n    var LoopSet = new Set();\n    pathElements.forEach(function (elements) {\n      var routeId = _this.getNewId('path');\n\n      var name = _this.getNewId('路径');\n\n      var isLoop = _this.isLoopPath(elements);\n\n      var elementStr = elements.join(',');\n\n      if (!LoopSet.has(elementStr)) {\n        LoopSet.add(elementStr);\n        pathes.push({\n          routeId: routeId,\n          name: name,\n          elements: elements,\n          type: isLoop,\n          weight: 0,\n          similarElement: ''\n        });\n      }\n    });\n    var oldPathes = JSON.parse(JSON.stringify(this.pathes)); // 1) 找到所有路径最相似的路径, 给旧路径标记其最接近的路径\n\n    pathes.forEach(function (newPath) {\n      for (var i = 0; i < oldPathes.length; i++) {\n        var oldPath = oldPathes[i];\n\n        var weight = _this.similar2Path(__spread(newPath.elements), __spread(oldPath.elements));\n\n        if (weight > newPath.weight && oldPath.weight <= weight) {\n          newPath.weight = weight;\n          newPath.similarElement = oldPath;\n\n          if (weight === oldPath.weight && oldPath.similarElement) {\n            // 特殊处理，如果两个路径都与同一条旧路径有相似的权重，则这两个路径的相似路径都置空\n            oldPath.similarElement.similarElement = null;\n            oldPath.similarElement.weight = 0;\n            oldPath.similarElement = null;\n            oldPath.weight = 0;\n          } else {\n            oldPath.similarElement = newPath;\n            oldPath.weight = weight;\n          }\n        }\n      }\n    }); // 2) 再次遍历所有路径，如果该路径的相似路径对应的相似路径是自己，那么就设置该路径id和name为其相似路径。\n\n    pathes.forEach(function (newPath) {\n      if (newPath.similarElement && newPath.similarElement.similarElement === newPath) {\n        newPath.routeId = newPath.similarElement.routeId;\n        newPath.name = newPath.similarElement.name;\n      }\n\n      delete newPath.similarElement;\n      delete newPath.weight;\n    });\n    this.setPathes(pathes);\n    return pathes;\n  };\n\n  FlowPath.prototype.similar2Path = function (x, y) {\n    var z = 0;\n    var s = x.length + y.length;\n    x.sort();\n    y.sort();\n    var a = x.shift();\n    var b = y.shift();\n\n    while (a !== undefined && b !== undefined) {\n      if (a === b) {\n        z++;\n        a = x.shift();\n        b = y.shift();\n      } else if (a < b) {\n        a = x.shift();\n      } else if (a > b) {\n        b = y.shift();\n      }\n    }\n\n    return z / s * 200;\n  };\n\n  FlowPath.prototype.getNewId = function (prefix) {\n    return prefix + \"_\" + getBpmnId();\n  };\n  /**\n   * 判断是否为循环路径\n   * 由于前面进行了特殊处理，将循环部分单独提出来作为路径\n   * 所有循环路径必定开始节点等于结束节点。\n   */\n\n\n  FlowPath.prototype.isLoopPath = function (elements) {\n    var length = elements.length;\n    return elements.indexOf(elements[length - 1]) !== length - 1 ? 1 : 0;\n  };\n\n  FlowPath.pluginName = 'flowPath';\n  return FlowPath;\n}();\n\nexport { FlowPath };","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/@logicflow/extension/es/tools/flow-path/index.js"],"names":["__read","o","n","m","Symbol","iterator","i","call","r","ar","e","next","done","push","value","error","__spread","arguments","length","concat","getBpmnId","FlowPath","_a","_this","lf","pathes","getPathes","startNodeType","Error","setRawPathes","setPathes","getRawPathes","setStartNodeType","type","prototype","map","routeId","name","elements","similarElement","weight","graphData","getGraphRawData","nodesMap","Map","startNodeIds","nodes","forEach","node","set","id","data","nextNodes","edges","edge","get","sourceNodeId","targetNodeId","pathElements","findPathElements","getNewPathes","newPathes","subPath","p","idx","indexOf","slice","LoopSet","Set","getNewId","isLoop","isLoopPath","elementStr","join","has","add","oldPathes","JSON","parse","stringify","newPath","oldPath","similar2Path","x","y","z","s","sort","a","shift","b","undefined","prefix","pluginName"],"mappings":"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","sourcesContent":["/**\n * 路径插件，此插件支持获取绘制的图中所有的路径。\n * 需要指定开始节点类型。\n */\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nimport { getBpmnId } from '../../bpmn/getBpmnId';\nvar FlowPath = /** @class */ (function () {\n    function FlowPath(_a) {\n        var _this = this;\n        var lf = _a.lf;\n        this.lf = lf;\n        this.pathes = [];\n        // 给lf添加方法\n        lf.getPathes = function () {\n            if (!_this.startNodeType) {\n                throw new Error('需要预先指定开始节点类型');\n            }\n            return _this.getPathes();\n        };\n        lf.setRawPathes = function (pathes) {\n            _this.setPathes(pathes);\n        };\n        lf.getRawPathes = function () { return _this.pathes; };\n        lf.setStartNodeType = function (type) {\n            _this.startNodeType = type;\n        };\n    }\n    FlowPath.prototype.setPathes = function (pathes) {\n        this.pathes = pathes.map(function (_a) {\n            var routeId = _a.routeId, name = _a.name, elements = _a.elements, type = _a.type;\n            return ({\n                routeId: routeId,\n                name: name,\n                elements: elements,\n                type: type,\n                similarElement: null,\n                weight: 0,\n            });\n        });\n    };\n    FlowPath.prototype.getPathes = function () {\n        var _this = this;\n        var graphData = this.lf.getGraphRawData();\n        var nodesMap = new Map();\n        var startNodeIds = [];\n        graphData.nodes.forEach(function (node) {\n            nodesMap.set(node.id, {\n                id: node.id,\n                data: node,\n                nextNodes: [],\n            });\n            if (node.type === _this.startNodeType) {\n                startNodeIds.push(node.id);\n            }\n        });\n        graphData.edges.forEach(function (edge) {\n            var node = nodesMap.get(edge.sourceNodeId);\n            node.nextNodes.push(edge.targetNodeId);\n        });\n        var pathElements = [];\n        startNodeIds.forEach(function (id) {\n            pathElements = pathElements.concat(_this.findPathElements(nodesMap.get(id), nodesMap, []));\n        });\n        return this.getNewPathes(pathElements);\n    };\n    FlowPath.prototype.findPathElements = function (node, nodesMap, elements) {\n        if (elements === void 0) { elements = []; }\n        var newPathes = __spread(elements);\n        newPathes.push(node.id);\n        if (node.nextNodes.length === 0) {\n            return [newPathes];\n        }\n        var subPath = [];\n        for (var i = 0; i < node.nextNodes.length; i++) {\n            var n = nodesMap.get(node.nextNodes[i]);\n            var p = void 0;\n            // 循环路径\n            var idx = newPathes.indexOf(n.id);\n            if (idx !== -1) {\n                p = [__spread(newPathes.slice(idx), [n.id])];\n            }\n            else {\n                p = this.findPathElements(n, nodesMap, __spread(newPathes));\n            }\n            subPath = subPath.concat(p);\n        }\n        return subPath;\n    };\n    /**\n     * 设置路径id\n     * 如果存在原始路径Id, 则需要比较新路径是否在原始路径中存在相似路径\n     * 如果有，则尽量使用原始路径。\n     * 相似路径\n     * 1. 如果所有的节点都相同，则必定为同一路径。(包括顺序不同)\n     * 2. 如果新路径比原来路径少了或者多了部分节点，则记录为相似路径。基于不同的差异，标记不同的权重。\n     * 3. 基于新路径在旧路径占用权限，设置新路径Id.\n     * 4. 如果某一条旧路径被多条新路径标记为相同的权重，则这两条新路径都使用新Id.\n     */\n    FlowPath.prototype.getNewPathes = function (pathElements) {\n        var _this = this;\n        var pathes = [];\n        // 由于循环路径不包括开始，所以存在重复的情况，此处去重。\n        var LoopSet = new Set();\n        pathElements.forEach(function (elements) {\n            var routeId = _this.getNewId('path');\n            var name = _this.getNewId('路径');\n            var isLoop = _this.isLoopPath(elements);\n            var elementStr = elements.join(',');\n            if (!LoopSet.has(elementStr)) {\n                LoopSet.add(elementStr);\n                pathes.push({\n                    routeId: routeId,\n                    name: name,\n                    elements: elements,\n                    type: isLoop,\n                    weight: 0,\n                    similarElement: '',\n                });\n            }\n        });\n        var oldPathes = JSON.parse(JSON.stringify(this.pathes));\n        // 1) 找到所有路径最相似的路径, 给旧路径标记其最接近的路径\n        pathes.forEach(function (newPath) {\n            for (var i = 0; i < oldPathes.length; i++) {\n                var oldPath = oldPathes[i];\n                var weight = _this.similar2Path(__spread(newPath.elements), __spread(oldPath.elements));\n                if (weight > newPath.weight && oldPath.weight <= weight) {\n                    newPath.weight = weight;\n                    newPath.similarElement = oldPath;\n                    if (weight === oldPath.weight && oldPath.similarElement) {\n                        // 特殊处理，如果两个路径都与同一条旧路径有相似的权重，则这两个路径的相似路径都置空\n                        oldPath.similarElement.similarElement = null;\n                        oldPath.similarElement.weight = 0;\n                        oldPath.similarElement = null;\n                        oldPath.weight = 0;\n                    }\n                    else {\n                        oldPath.similarElement = newPath;\n                        oldPath.weight = weight;\n                    }\n                }\n            }\n        });\n        // 2) 再次遍历所有路径，如果该路径的相似路径对应的相似路径是自己，那么就设置该路径id和name为其相似路径。\n        pathes.forEach(function (newPath) {\n            if (newPath.similarElement && newPath.similarElement.similarElement === newPath) {\n                newPath.routeId = newPath.similarElement.routeId;\n                newPath.name = newPath.similarElement.name;\n            }\n            delete newPath.similarElement;\n            delete newPath.weight;\n        });\n        this.setPathes(pathes);\n        return pathes;\n    };\n    FlowPath.prototype.similar2Path = function (x, y) {\n        var z = 0;\n        var s = x.length + y.length;\n        x.sort();\n        y.sort();\n        var a = x.shift();\n        var b = y.shift();\n        while (a !== undefined && b !== undefined) {\n            if (a === b) {\n                z++;\n                a = x.shift();\n                b = y.shift();\n            }\n            else if (a < b) {\n                a = x.shift();\n            }\n            else if (a > b) {\n                b = y.shift();\n            }\n        }\n        return (z / s) * 200;\n    };\n    FlowPath.prototype.getNewId = function (prefix) {\n        return prefix + \"_\" + getBpmnId();\n    };\n    /**\n     * 判断是否为循环路径\n     * 由于前面进行了特殊处理，将循环部分单独提出来作为路径\n     * 所有循环路径必定开始节点等于结束节点。\n     */\n    FlowPath.prototype.isLoopPath = function (elements) {\n        var length = elements.length;\n        return elements.indexOf(elements[length - 1]) !== length - 1 ? 1 : 0;\n    };\n    FlowPath.pluginName = 'flowPath';\n    return FlowPath;\n}());\nexport { FlowPath, };\n"]},"metadata":{},"sourceType":"module"}