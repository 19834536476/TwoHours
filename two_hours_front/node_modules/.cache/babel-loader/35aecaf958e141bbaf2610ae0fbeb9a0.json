{"ast":null,"code":"// 这个里面的函数有些在core中已经存在，为了解耦关系，没有引用\nvar SegmentDirection;\n\n(function (SegmentDirection) {\n  SegmentDirection[\"HORIZONTAL\"] = \"horizontal\";\n  SegmentDirection[\"VERTICAL\"] = \"vertical\";\n})(SegmentDirection || (SegmentDirection = {}));\n/* 判断一个点是否在线段中\n入参点：point, 线段起终点，start,end,\n返回值： 在线段中true，否则false\n*/\n\n\nexport var isInSegment = function isInSegment(point, start, end) {\n  var x = point.x,\n      y = point.y;\n  return (x - start.x) * (x - end.x) <= 0 && (y - start.y) * (y - end.y) <= 0;\n};\n/* 获取节点bbox */\n\nvar getNodeBBox = function getNodeBBox(node) {\n  var x = node.x,\n      y = node.y,\n      width = node.width,\n      height = node.height;\n  var bBox = {\n    minX: x - width / 2,\n    minY: y - height / 2,\n    maxX: x + width / 2,\n    maxY: y + height / 2,\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    centerX: x,\n    centerY: y\n  };\n  return bBox;\n};\n/* 判断线段的方向 */\n\n\nvar segmentDirection = function segmentDirection(start, end) {\n  var direction;\n\n  if (start.x === end.x) {\n    direction = SegmentDirection.VERTICAL;\n  } else if (start.y === end.y) {\n    direction = SegmentDirection.HORIZONTAL;\n  }\n\n  return direction;\n}; // 节点是够在线段内，求出节点与线段的交点\n\n\nexport var corssPointInSegement = function corssPointInSegement(node, start, end) {\n  var bBox = getNodeBBox(node);\n  var direction = segmentDirection(start, end);\n  var maxX = Math.max(start.x, end.x);\n  var minX = Math.min(start.x, end.x);\n  var maxY = Math.max(start.y, end.y);\n  var minY = Math.min(start.y, end.y);\n  var x = node.x,\n      y = node.y,\n      width = node.width,\n      height = node.height;\n\n  if (direction === SegmentDirection.HORIZONTAL) {\n    // 同一水平线\n    if (start.y === y && maxX >= bBox.maxX && minX <= bBox.minX) {\n      return {\n        startCrossPoint: {\n          x: start.x > end.x ? x + width / 2 : x - width / 2,\n          y: y\n        },\n        endCrossPoint: {\n          x: start.x > end.x ? x - width / 2 : x + width / 2,\n          y: y\n        }\n      };\n    }\n  } else if (direction === SegmentDirection.VERTICAL) {\n    // 同一垂直线\n    if (start.x === node.x && maxY >= bBox.maxY && minY <= bBox.minY) {\n      return {\n        startCrossPoint: {\n          x: x,\n          y: start.y > end.y ? y + height / 2 : y - height / 2\n        },\n        endCrossPoint: {\n          x: x,\n          y: start.y > end.y ? y - height / 2 : y + height / 2\n        }\n      };\n    }\n  }\n}; // 节点是否在线段内\n// eslint-disable-next-line max-len\n\nexport var isNodeInSegement = function isNodeInSegement(node, polyline) {\n  var x = node.x,\n      y = node.y;\n  var pointsList = polyline.pointsList;\n\n  for (var i = 0; i < pointsList.length - 1; i++) {\n    if (isInSegment({\n      x: x,\n      y: y\n    }, pointsList[i], pointsList[i + 1])) {\n      var bBoxCross = corssPointInSegement(node, pointsList[i], pointsList[i + 1]);\n\n      if (bBoxCross) {\n        return {\n          crossIndex: i + 1,\n          crossPoints: bBoxCross\n        };\n      }\n    }\n  }\n\n  return {\n    crossIndex: -1,\n    crossPoints: {\n      startCrossPoint: {\n        x: 0,\n        y: 0\n      },\n      endCrossPoint: {\n        x: 0,\n        y: 0\n      }\n    }\n  };\n};","map":{"version":3,"sources":["F:/Desktop/two_hours_front/node_modules/@logicflow/extension/es/insert-node-in-polyline/edge.js"],"names":["SegmentDirection","isInSegment","point","start","end","x","y","getNodeBBox","node","width","height","bBox","minX","minY","maxX","maxY","centerX","centerY","segmentDirection","direction","VERTICAL","HORIZONTAL","corssPointInSegement","Math","max","min","startCrossPoint","endCrossPoint","isNodeInSegement","polyline","pointsList","i","length","bBoxCross","crossIndex","crossPoints"],"mappings":"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","sourcesContent":["// 这个里面的函数有些在core中已经存在，为了解耦关系，没有引用\nvar SegmentDirection;\n(function (SegmentDirection) {\n    SegmentDirection[\"HORIZONTAL\"] = \"horizontal\";\n    SegmentDirection[\"VERTICAL\"] = \"vertical\";\n})(SegmentDirection || (SegmentDirection = {}));\n/* 判断一个点是否在线段中\n入参点：point, 线段起终点，start,end,\n返回值： 在线段中true，否则false\n*/\nexport var isInSegment = function (point, start, end) {\n    var x = point.x, y = point.y;\n    return (x - start.x) * (x - end.x) <= 0\n        && (y - start.y) * (y - end.y) <= 0;\n};\n/* 获取节点bbox */\nvar getNodeBBox = function (node) {\n    var x = node.x, y = node.y, width = node.width, height = node.height;\n    var bBox = {\n        minX: x - width / 2,\n        minY: y - height / 2,\n        maxX: x + width / 2,\n        maxY: y + height / 2,\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        centerX: x,\n        centerY: y,\n    };\n    return bBox;\n};\n/* 判断线段的方向 */\nvar segmentDirection = function (start, end) {\n    var direction;\n    if (start.x === end.x) {\n        direction = SegmentDirection.VERTICAL;\n    }\n    else if (start.y === end.y) {\n        direction = SegmentDirection.HORIZONTAL;\n    }\n    return direction;\n};\n// 节点是够在线段内，求出节点与线段的交点\nexport var corssPointInSegement = function (node, start, end) {\n    var bBox = getNodeBBox(node);\n    var direction = segmentDirection(start, end);\n    var maxX = Math.max(start.x, end.x);\n    var minX = Math.min(start.x, end.x);\n    var maxY = Math.max(start.y, end.y);\n    var minY = Math.min(start.y, end.y);\n    var x = node.x, y = node.y, width = node.width, height = node.height;\n    if (direction === SegmentDirection.HORIZONTAL) {\n        // 同一水平线\n        if (start.y === y && maxX >= bBox.maxX && minX <= bBox.minX) {\n            return {\n                startCrossPoint: {\n                    x: start.x > end.x ? x + (width / 2) : x - (width / 2),\n                    y: y,\n                },\n                endCrossPoint: {\n                    x: start.x > end.x ? x - (width / 2) : x + (width / 2),\n                    y: y,\n                },\n            };\n        }\n    }\n    else if (direction === SegmentDirection.VERTICAL) {\n        // 同一垂直线\n        if (start.x === node.x && maxY >= bBox.maxY && minY <= bBox.minY) {\n            return {\n                startCrossPoint: {\n                    x: x,\n                    y: start.y > end.y ? y + (height / 2) : y - (height / 2),\n                },\n                endCrossPoint: {\n                    x: x,\n                    y: start.y > end.y ? y - (height / 2) : y + (height / 2),\n                },\n            };\n        }\n    }\n};\n// 节点是否在线段内\n// eslint-disable-next-line max-len\nexport var isNodeInSegement = function (node, polyline) {\n    var x = node.x, y = node.y;\n    var pointsList = polyline.pointsList;\n    for (var i = 0; i < pointsList.length - 1; i++) {\n        if (isInSegment({ x: x, y: y }, pointsList[i], pointsList[i + 1])) {\n            var bBoxCross = corssPointInSegement(node, pointsList[i], pointsList[i + 1]);\n            if (bBoxCross) {\n                return {\n                    crossIndex: i + 1,\n                    crossPoints: bBoxCross,\n                };\n            }\n        }\n    }\n    return {\n        crossIndex: -1,\n        crossPoints: {\n            startCrossPoint: { x: 0, y: 0 },\n            endCrossPoint: { x: 0, y: 0 },\n        },\n    };\n};\n"]},"metadata":{},"sourceType":"module"}