{"ast":null,"code":"export var ModelType;\n\n(function (ModelType) {\n  ModelType[\"NODE\"] = \"node\";\n  ModelType[\"CIRCLE_NODE\"] = \"circle-node\";\n  ModelType[\"POLYGON_NODE\"] = \"polygon-node\";\n  ModelType[\"RECT_NODE\"] = \"rect-node\";\n  ModelType[\"HTML_NODE\"] = \"html-node\";\n  ModelType[\"TEXT_NODE\"] = \"text-node\";\n  ModelType[\"ELLIPSE_NODE\"] = \"ellipse-node\";\n  ModelType[\"DIAMOND_NODE\"] = \"diamond-node\";\n  ModelType[\"EDGE\"] = \"edge\";\n  ModelType[\"LINE_EDGE\"] = \"line-edge\";\n  ModelType[\"POLYLINE_EDGE\"] = \"polyline-edge\";\n  ModelType[\"BEZIER_EDGE\"] = \"bezier-edge\";\n  ModelType[\"GRAPH\"] = \"graph\";\n})(ModelType || (ModelType = {})); // 计算节点的box四角数据\n\n\nfunction getNodeBox(node) {\n  var x = node.x,\n      y = node.y,\n      width = node.width,\n      height = node.height;\n  return {\n    minX: x - width / 2,\n    minY: y - height / 2,\n    maxX: x + width / 2,\n    maxY: y + height / 2\n  };\n} // 计算矩形radius设置后，四个圆角的圆心\n\n\nfunction getRidusCenter(node) {\n  var nodeBox = getNodeBox(node);\n  var radius = node.radius;\n  var minX = nodeBox.minX,\n      minY = nodeBox.minY,\n      maxX = nodeBox.maxX,\n      maxY = nodeBox.maxY;\n  return [{\n    x: minX + radius,\n    y: minY + radius\n  }, {\n    x: maxX - radius,\n    y: minY + radius\n  }, {\n    x: maxX - radius,\n    y: maxY - radius\n  }, {\n    x: minX + radius,\n    y: maxY - radius\n  }];\n} // 获取矩形resize之后，与矩形连接边的新端点\n\n\nexport function getRectReizeEdgePoint(_a) {\n  var point = _a.point,\n      beforeNode = _a.beforeNode,\n      afterNode = _a.afterNode;\n  var x = point.x,\n      y = point.y;\n  var afterPoint = {\n    x: x,\n    y: y\n  };\n  var radius = beforeNode.radius;\n  var beforeNodeBox = getNodeBox(beforeNode);\n  var afterNodeBox = getNodeBox(afterNode);\n\n  if (x === beforeNodeBox.minX) {\n    // 左边\n    afterPoint.x = afterNodeBox.minX;\n    var pct = (y - beforeNode.y) / (beforeNode.height / 2 - radius);\n\n    if (pct) {\n      afterPoint.y = afterNode.y + (afterNode.height / 2 - radius) * pct;\n    } else {\n      afterPoint.y = afterNode.y;\n    }\n  } else if (x === beforeNodeBox.maxX) {\n    // 右边\n    afterPoint.x = afterNodeBox.maxX;\n    var pct = (y - beforeNode.y) / (beforeNode.height / 2 - radius);\n\n    if (pct) {\n      afterPoint.y = afterNode.y + (afterNode.height / 2 - radius) * pct;\n    } else {\n      afterPoint.y = afterNode.y;\n    }\n  } else if (y === beforeNodeBox.minY) {\n    // 上边\n    afterPoint.y = afterNodeBox.minY;\n    var pct = (x - beforeNode.x) / (beforeNode.width / 2 - radius);\n\n    if (pct) {\n      afterPoint.x = afterNode.x + (afterNode.width / 2 - radius) * pct;\n    } else {\n      afterPoint.x = afterNode.x;\n    }\n  } else if (y === beforeNodeBox.maxY) {\n    // 下边\n    afterPoint.y = afterNodeBox.maxY;\n    var pct = (x - beforeNode.x) / (beforeNode.width / 2 - radius);\n\n    if (pct) {\n      afterPoint.x = afterNode.x + (afterNode.width / 2 - radius) * pct;\n    } else {\n      afterPoint.x = afterNode.x;\n    }\n  } else {\n    // 在圆角部分\n    var beeforCoc = getRidusCenter(beforeNode);\n    var afterCoc = getRidusCenter(afterNode);\n    var nodeBox = getNodeBox(beforeNode);\n    var minX = nodeBox.minX,\n        minY = nodeBox.minY,\n        maxX = nodeBox.maxX,\n        maxY = nodeBox.maxY;\n    var index = -1;\n\n    if (x - minX < radius && y - minY < radius) {\n      // 左上角\n      index = 0;\n    } else if (maxX - x < radius && y - minY < radius) {\n      // 右上角\n      index = 1;\n    } else if (maxX - x < radius && maxY - y < radius) {\n      // 右下角\n      index = 2;\n    } else if (x - minX < radius && minY - y < radius) {\n      // 左下角\n      index = 3;\n    }\n\n    if (index > -1) {\n      // 根据夹角角度计算位置\n      var angle = Math.atan2(y - beeforCoc[index].y, x - beeforCoc[index].x);\n      afterPoint.x = afterCoc[index].x + radius * Math.cos(angle);\n      afterPoint.y = afterCoc[index].y + radius * Math.sin(angle);\n    }\n  }\n\n  return afterPoint;\n} // 获取椭圆resize之后，与椭圆连接边的新端点\n\nexport function getEllipseReizeEdgePoint(_a) {\n  var point = _a.point,\n      beforeNode = _a.beforeNode,\n      afterNode = _a.afterNode;\n  var rx = afterNode.rx,\n      ry = afterNode.ry;\n  var afterPoint = point; // 将椭圆中心当做中心点(0,0)，放大缩小前点与X周夹角\n\n  var tan = (point.y - beforeNode.y) / (point.x - beforeNode.x); // 方便与公式对照，将rx命名为a,ry命名为b\n\n  var a = rx;\n  var b = ry;\n  var x;\n  var y; // 将椭圆中心当做中心点(0,0),计算放大缩小后，同一夹角下，点相对位置\n\n  if (tan >= Infinity) {\n    //  θ = PI / 2\n    x = 0;\n    y = b;\n  } else if (tan <= -Infinity) {\n    //  θ = 3 * PI / 2\n    x = 0;\n    y = -b;\n  } else if (point.x - beforeNode.x > 0) {\n    //  0 < θ = PI / 2   或者  3 * PI / 2 < θ = 2 * PI\n    //  一四象限\n    x = a * b / Math.sqrt(b * b + a * a * tan * tan);\n    y = a * b * tan / Math.sqrt(b * b + a * a * tan * tan);\n  } else {\n    //  PI / 2 < θ  3 * PI / 2\n    //  二三象限\n    x = -(a * b) / Math.sqrt(b * b + a * a * tan * tan);\n    y = -(a * b * tan) / Math.sqrt(b * b + a * a * tan * tan);\n  }\n\n  afterPoint = {\n    x: x + afterNode.x,\n    y: y + afterNode.y\n  };\n  return afterPoint;\n} // 获取菱形resize之后，与菱形连接边的新端点\n\nexport function getDiamondReizeEdgePoint(_a) {\n  var point = _a.point,\n      beforeNode = _a.beforeNode,\n      afterNode = _a.afterNode;\n  var afterPoint = point;\n  var x;\n  var y;\n  var px = point.x - beforeNode.x;\n  var py = point.y - beforeNode.y;\n  var rxBefore = beforeNode.rx;\n  var ryBefore = beforeNode.ry; // eslint-disable-next-line max-len\n\n  var pct = Math.sqrt((rxBefore - Math.abs(px)) * (rxBefore - Math.abs(px)) + py * py) / Math.sqrt(rxBefore * rxBefore + ryBefore * ryBefore);\n  var rxAfter = afterNode.rx;\n  var ryAfter = afterNode.ry; // eslint-disable-next-line max-len\n\n  var a = Math.sqrt((rxAfter * rxAfter + ryAfter * ryAfter) * pct * pct * (rxAfter * rxAfter / (rxAfter * rxAfter + ryAfter * ryAfter)));\n  var b = a * (ryAfter / rxAfter);\n\n  if (px >= 0) {\n    // eslint-disable-next-line max-len\n    x = rxAfter - a;\n  } else {\n    x = a - rxAfter;\n  }\n\n  if (py > 0) {\n    y = b;\n  } else {\n    y = -b;\n  }\n\n  afterPoint = {\n    x: x + afterNode.x,\n    y: y + afterNode.y\n  };\n  return afterPoint;\n}","map":{"version":3,"sources":["F:/Desktop/繁星教育/TH资料/two_hours_front/node_modules/@logicflow/extension/es/NodeResize/Control/Util.js"],"names":["ModelType","getNodeBox","node","x","y","width","height","minX","minY","maxX","maxY","getRidusCenter","nodeBox","radius","getRectReizeEdgePoint","_a","point","beforeNode","afterNode","afterPoint","beforeNodeBox","afterNodeBox","pct","beeforCoc","afterCoc","index","angle","Math","atan2","cos","sin","getEllipseReizeEdgePoint","rx","ry","tan","a","b","Infinity","sqrt","getDiamondReizeEdgePoint","px","py","rxBefore","ryBefore","abs","rxAfter","ryAfter"],"mappings":"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","sourcesContent":["export var ModelType;\n(function (ModelType) {\n    ModelType[\"NODE\"] = \"node\";\n    ModelType[\"CIRCLE_NODE\"] = \"circle-node\";\n    ModelType[\"POLYGON_NODE\"] = \"polygon-node\";\n    ModelType[\"RECT_NODE\"] = \"rect-node\";\n    ModelType[\"HTML_NODE\"] = \"html-node\";\n    ModelType[\"TEXT_NODE\"] = \"text-node\";\n    ModelType[\"ELLIPSE_NODE\"] = \"ellipse-node\";\n    ModelType[\"DIAMOND_NODE\"] = \"diamond-node\";\n    ModelType[\"EDGE\"] = \"edge\";\n    ModelType[\"LINE_EDGE\"] = \"line-edge\";\n    ModelType[\"POLYLINE_EDGE\"] = \"polyline-edge\";\n    ModelType[\"BEZIER_EDGE\"] = \"bezier-edge\";\n    ModelType[\"GRAPH\"] = \"graph\";\n})(ModelType || (ModelType = {}));\n// 计算节点的box四角数据\nfunction getNodeBox(node) {\n    var x = node.x, y = node.y, width = node.width, height = node.height;\n    return {\n        minX: x - width / 2,\n        minY: y - height / 2,\n        maxX: x + width / 2,\n        maxY: y + height / 2,\n    };\n}\n// 计算矩形radius设置后，四个圆角的圆心\nfunction getRidusCenter(node) {\n    var nodeBox = getNodeBox(node);\n    var radius = node.radius;\n    var minX = nodeBox.minX, minY = nodeBox.minY, maxX = nodeBox.maxX, maxY = nodeBox.maxY;\n    return [\n        {\n            x: minX + radius,\n            y: minY + radius,\n        },\n        {\n            x: maxX - radius,\n            y: minY + radius,\n        },\n        {\n            x: maxX - radius,\n            y: maxY - radius,\n        },\n        {\n            x: minX + radius,\n            y: maxY - radius,\n        },\n    ];\n}\n// 获取矩形resize之后，与矩形连接边的新端点\nexport function getRectReizeEdgePoint(_a) {\n    var point = _a.point, beforeNode = _a.beforeNode, afterNode = _a.afterNode;\n    var x = point.x, y = point.y;\n    var afterPoint = {\n        x: x, y: y,\n    };\n    var radius = beforeNode.radius;\n    var beforeNodeBox = getNodeBox(beforeNode);\n    var afterNodeBox = getNodeBox(afterNode);\n    if (x === beforeNodeBox.minX) {\n        // 左边\n        afterPoint.x = afterNodeBox.minX;\n        var pct = (y - beforeNode.y) / (beforeNode.height / 2 - radius);\n        if (pct) {\n            afterPoint.y = afterNode.y + (afterNode.height / 2 - radius) * pct;\n        }\n        else {\n            afterPoint.y = afterNode.y;\n        }\n    }\n    else if (x === beforeNodeBox.maxX) {\n        // 右边\n        afterPoint.x = afterNodeBox.maxX;\n        var pct = (y - beforeNode.y) / (beforeNode.height / 2 - radius);\n        if (pct) {\n            afterPoint.y = afterNode.y + (afterNode.height / 2 - radius) * pct;\n        }\n        else {\n            afterPoint.y = afterNode.y;\n        }\n    }\n    else if (y === beforeNodeBox.minY) {\n        // 上边\n        afterPoint.y = afterNodeBox.minY;\n        var pct = (x - beforeNode.x) / (beforeNode.width / 2 - radius);\n        if (pct) {\n            afterPoint.x = afterNode.x + (afterNode.width / 2 - radius) * pct;\n        }\n        else {\n            afterPoint.x = afterNode.x;\n        }\n    }\n    else if (y === beforeNodeBox.maxY) {\n        // 下边\n        afterPoint.y = afterNodeBox.maxY;\n        var pct = (x - beforeNode.x) / (beforeNode.width / 2 - radius);\n        if (pct) {\n            afterPoint.x = afterNode.x + (afterNode.width / 2 - radius) * pct;\n        }\n        else {\n            afterPoint.x = afterNode.x;\n        }\n    }\n    else {\n        // 在圆角部分\n        var beeforCoc = getRidusCenter(beforeNode);\n        var afterCoc = getRidusCenter(afterNode);\n        var nodeBox = getNodeBox(beforeNode);\n        var minX = nodeBox.minX, minY = nodeBox.minY, maxX = nodeBox.maxX, maxY = nodeBox.maxY;\n        var index = -1;\n        if (x - minX < radius && y - minY < radius) {\n            // 左上角\n            index = 0;\n        }\n        else if (maxX - x < radius && y - minY < radius) {\n            // 右上角\n            index = 1;\n        }\n        else if (maxX - x < radius && maxY - y < radius) {\n            // 右下角\n            index = 2;\n        }\n        else if (x - minX < radius && minY - y < radius) {\n            // 左下角\n            index = 3;\n        }\n        if (index > -1) {\n            // 根据夹角角度计算位置\n            var angle = Math.atan2((y - beeforCoc[index].y), (x - beeforCoc[index].x));\n            afterPoint.x = afterCoc[index].x + radius * Math.cos(angle);\n            afterPoint.y = afterCoc[index].y + radius * Math.sin(angle);\n        }\n    }\n    return afterPoint;\n}\n// 获取椭圆resize之后，与椭圆连接边的新端点\nexport function getEllipseReizeEdgePoint(_a) {\n    var point = _a.point, beforeNode = _a.beforeNode, afterNode = _a.afterNode;\n    var rx = afterNode.rx, ry = afterNode.ry;\n    var afterPoint = point;\n    // 将椭圆中心当做中心点(0,0)，放大缩小前点与X周夹角\n    var tan = (point.y - beforeNode.y) / (point.x - beforeNode.x);\n    // 方便与公式对照，将rx命名为a,ry命名为b\n    var a = rx;\n    var b = ry;\n    var x;\n    var y;\n    // 将椭圆中心当做中心点(0,0),计算放大缩小后，同一夹角下，点相对位置\n    if (tan >= Infinity) {\n        //  θ = PI / 2\n        x = 0;\n        y = b;\n    }\n    else if (tan <= -Infinity) {\n        //  θ = 3 * PI / 2\n        x = 0;\n        y = -b;\n    }\n    else if (point.x - beforeNode.x > 0) {\n        //  0 < θ = PI / 2   或者  3 * PI / 2 < θ = 2 * PI\n        //  一四象限\n        x = (a * b) / (Math.sqrt((b * b) + a * a * tan * tan));\n        y = (a * b * tan) / (Math.sqrt((b * b) + a * a * tan * tan));\n    }\n    else {\n        //  PI / 2 < θ  3 * PI / 2\n        //  二三象限\n        x = -(a * b) / (Math.sqrt((b * b) + a * a * tan * tan));\n        y = -(a * b * tan) / (Math.sqrt((b * b) + a * a * tan * tan));\n    }\n    afterPoint = { x: x + afterNode.x, y: y + afterNode.y };\n    return afterPoint;\n}\n// 获取菱形resize之后，与菱形连接边的新端点\nexport function getDiamondReizeEdgePoint(_a) {\n    var point = _a.point, beforeNode = _a.beforeNode, afterNode = _a.afterNode;\n    var afterPoint = point;\n    var x;\n    var y;\n    var px = point.x - beforeNode.x;\n    var py = point.y - beforeNode.y;\n    var rxBefore = beforeNode.rx;\n    var ryBefore = beforeNode.ry;\n    // eslint-disable-next-line max-len\n    var pct = Math.sqrt((rxBefore - Math.abs(px)) * (rxBefore - Math.abs(px)) + py * py) / Math.sqrt(rxBefore * rxBefore + ryBefore * ryBefore);\n    var rxAfter = afterNode.rx;\n    var ryAfter = afterNode.ry;\n    // eslint-disable-next-line max-len\n    var a = Math.sqrt((rxAfter * rxAfter + ryAfter * ryAfter) * pct * pct * ((rxAfter * rxAfter) / (rxAfter * rxAfter + ryAfter * ryAfter)));\n    var b = a * (ryAfter / rxAfter);\n    if (px >= 0) {\n        // eslint-disable-next-line max-len\n        x = rxAfter - a;\n    }\n    else {\n        x = a - rxAfter;\n    }\n    if (py > 0) {\n        y = b;\n    }\n    else {\n        y = -b;\n    }\n    afterPoint = {\n        x: x + afterNode.x,\n        y: y + afterNode.y,\n    };\n    return afterPoint;\n}\n"]},"metadata":{},"sourceType":"module"}